<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta charSet="utf-8"/><meta name="description" content="Kelvin&#x27;s blog"/><link rel="icon" href="/images/favicon.ico"/><title>Kelvin&#x27;s Blog</title><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/879303eddaa0d6c4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/879303eddaa0d6c4.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-431ff9505f7ded9a.js" defer=""></script><script src="/_next/static/chunks/pages/posts-9ef05a2d01339ef5.js" defer=""></script><script src="/_next/static/kbX4A-R647mFDHRGgWlVs/_buildManifest.js" defer=""></script><script src="/_next/static/kbX4A-R647mFDHRGgWlVs/_ssgManifest.js" defer=""></script><script src="/_next/static/kbX4A-R647mFDHRGgWlVs/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="container"><nav class="navbar"><div class="navbar-content"><ul><li><a href="/">首页</a></li><li><a class="active" href="/posts">秘笈</a></li><li><a href="/">八股</a></li><li><a href="/">奇术</a></li><li><a href="/">轮子</a></li><li><a href="/">鄙人</a></li></ul></div></nav><main class="main"><ul class="main-posts-list"><li><article><div class="posts-list-date">Feb 17, 2022</div><a href="/post/recreate-axios-from-scratch-iii"><h1>Axios 源码阅读笔记之——徒手撕 Ajax（三）</h1></a><p>在上一年（过完年相当于去年……）的文章中，我们实现了“简陋版” Axios 的拦截器功能。这一次，我们来看看取消请求的功能该如何实现。</p></article></li><li><article><div class="posts-list-date">JAN 14, 2022</div><a href="/post/recreate-axios-from-scratch-ii"><h1>Axios 源码阅读笔记之——徒手撕 Ajax（二）</h1></a><p>上一次我们已经封装了一个“简陋版”的 Axios，实现了配置化，多种方式调用，Promise 化等功能。除此以外，Axios 还有两个很重要的功能：拦截器、取消请求。这一次我们先来实现一个拦截器的功能。</p></article></li><li><article><div class="posts-list-date">DEC 30, 2021</div><a href="/post/recreate-axios-from-scratch-i"><h1>Axios 源码阅读笔记之——徒手撕 Ajax（一）</h1></a><p>花了两三天的时间，把 Axios 的源码过了一遍。不得不说，Axios 的源码确实很适合小白，逻辑不复杂，也能看到很多巧妙的地方。看一遍，然后自己把核心的逻辑实现一遍，确实能学到很多东西，在此记录一下。</p></article></li><li><article><div class="posts-list-date">DEC 22, 2021</div><a href="/post/my-first-fullstack-project"><h1>第一个全栈项目上线小结</h1></a><p>前前后后忙了差不多有一个月的时候，终于把我第一个独立完成的全栈项目（正式）上线了。过程中遇到了无数的坑，在此回顾小结一下。</p></article></li><li><article><div class="posts-list-date">NOV 12, 2021</div><a href="/post/solving-tree-problems"><h1>算法小抄——“二叉树”的套路</h1></a><p>“树”是最常见的数据结构之一，与“二叉树”相关的题也是 Leetcode 中最为常见的。而且大部分算法技巧，都与树的遍历有关，很多算法题，本质上就是树的遍历。二叉树的题目，都可以用框架去解决。</p></article></li><li><article><div class="posts-list-date">OCT 29, 2021</div><a href="/post/compilation-in-javascript"><h1>JavaScript 的“编译”过程都做了什么？</h1></a><p>所谓的“编译”，并不是“编译型语言”的那个编译，而是指在 JS 代码执行之前，解析器所进行的一系列动作，像词法分析、变量初始化等。由于它们发生在代码真正“执行”之前，所以大家习惯称之为“编译”或“预编译”。整个“编译”阶段，主要涉及到的是执行上下文与执行栈（调用栈）这两个核心的概念，了解这两个概念，对于理解 JS 的底层执行机制，如变量提升、this、闭包等，都会有很大的帮助。</p></article></li><li><article><div class="posts-list-date">OCT 22, 2021</div><a href="/post/how-to-build-a-static-blog-with-nextjs-and-mdx-i"><h1>使用 Next.js 与 MDX 搭建一个静态博客（一）</h1></a><p>花了几天时间，重新搭了一个 blog。考虑到之前一直在写 Vue，这次想换 React 练练手，调研了一堆轮子后，花了九牛二虎之力才最终定下来，用 Next.js 和 MDX 来搭。过程中遇到了无数个坑，总结得到了这篇文章。</p></article></li></ul></main><footer><div>Build with ♥ @GZ</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postsData":[{"id":"recreate-axios-from-scratch-iii","title":"Axios 源码阅读笔记之——徒手撕 Ajax（三）","date":"Feb 17, 2022","desc":"在上一年（过完年相当于去年……）的文章中，我们实现了“简陋版” Axios 的拦截器功能。这一次，我们来看看取消请求的功能该如何实现。"},{"id":"recreate-axios-from-scratch-ii","title":"Axios 源码阅读笔记之——徒手撕 Ajax（二）","date":"JAN 14, 2022","desc":"上一次我们已经封装了一个“简陋版”的 Axios，实现了配置化，多种方式调用，Promise 化等功能。除此以外，Axios 还有两个很重要的功能：拦截器、取消请求。这一次我们先来实现一个拦截器的功能。"},{"id":"recreate-axios-from-scratch-i","title":"Axios 源码阅读笔记之——徒手撕 Ajax（一）","date":"DEC 30, 2021","desc":"花了两三天的时间，把 Axios 的源码过了一遍。不得不说，Axios 的源码确实很适合小白，逻辑不复杂，也能看到很多巧妙的地方。看一遍，然后自己把核心的逻辑实现一遍，确实能学到很多东西，在此记录一下。"},{"id":"my-first-fullstack-project","title":"第一个全栈项目上线小结","date":"DEC 22, 2021","desc":"前前后后忙了差不多有一个月的时候，终于把我第一个独立完成的全栈项目（正式）上线了。过程中遇到了无数的坑，在此回顾小结一下。"},{"id":"solving-tree-problems","title":"算法小抄——“二叉树”的套路","date":"NOV 12, 2021","desc":"“树”是最常见的数据结构之一，与“二叉树”相关的题也是 Leetcode 中最为常见的。而且大部分算法技巧，都与树的遍历有关，很多算法题，本质上就是树的遍历。二叉树的题目，都可以用框架去解决。"},{"id":"compilation-in-javascript","title":"JavaScript 的“编译”过程都做了什么？","date":"OCT 29, 2021","desc":"所谓的“编译”，并不是“编译型语言”的那个编译，而是指在 JS 代码执行之前，解析器所进行的一系列动作，像词法分析、变量初始化等。由于它们发生在代码真正“执行”之前，所以大家习惯称之为“编译”或“预编译”。整个“编译”阶段，主要涉及到的是执行上下文与执行栈（调用栈）这两个核心的概念，了解这两个概念，对于理解 JS 的底层执行机制，如变量提升、this、闭包等，都会有很大的帮助。"},{"id":"how-to-build-a-static-blog-with-nextjs-and-mdx-i","title":"使用 Next.js 与 MDX 搭建一个静态博客（一）","date":"OCT 22, 2021","desc":"花了几天时间，重新搭了一个 blog。考虑到之前一直在写 Vue，这次想换 React 练练手，调研了一堆轮子后，花了九牛二虎之力才最终定下来，用 Next.js 和 MDX 来搭。过程中遇到了无数个坑，总结得到了这篇文章。"}]},"__N_SSG":true},"page":"/posts","query":{},"buildId":"kbX4A-R647mFDHRGgWlVs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>