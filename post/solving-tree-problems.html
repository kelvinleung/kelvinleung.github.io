<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta charSet="utf-8"/><meta name="description" content="Kelvin&#x27;s blog"/><link rel="icon" href="/images/favicon.ico"/><title>算法小抄——“二叉树”的套路</title><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/90fcd0f4d638a169.css" as="style"/><link rel="stylesheet" href="/_next/static/css/90fcd0f4d638a169.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e9e30af88e81fae5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e9e30af88e81fae5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-cf80afe0fcf9a721.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d6e5713b8459b479.js" defer=""></script><script src="/_next/static/chunks/259-40724c9c857ae4fb.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-95d4c0924337a51d.js" defer=""></script><script src="/_next/static/5gWJ-3w7KsPABD87B5u4P/_buildManifest.js" defer=""></script><script src="/_next/static/5gWJ-3w7KsPABD87B5u4P/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="max-w-[800px] min-h-screen pt-16 m-auto flex flex-col"><nav class="fixed inset-x-0 top-0 z-50 bg-white shadow-sm"><div class="max-w-[800px] px-6 py-2 m-auto flex justify-between items-center"><a class="navbar__menu-item text-neutral-800 font-bold" href="/">&lt;般若阁 /&gt;</a><button class="navbar__menu-item sm:hidden">机关</button></div></nav><main class="p-6 flex flex-col grow"><main><article><div class="mt-8 mb-16"><h1 class="my-4 text-2xl text-neutral-800 font-bold">算法小抄——“二叉树”的套路</h1><p class="text-sm text-neutral-400">NOV 12, 2021</p></div><div class="post-content leading-loose text-neutral-600"><p>“树”是最常见的数据结构之一，与“二叉树”相关的题也是 Leetcode 中最常见的。而且大部分算法技巧，都与树的遍历有关，很多算法题，本质上就是树的遍历。二叉树的题目，都可以用下面的框架去解决：</p>
<div class="my-8 rounded-2xl overflow-hidden bg-[#282c34]"><div class="relative px-4 py-2 text-sm font-bold text-white text-center"><ul class="absolute inset-y-0 left-0 flex items-center gap-2 px-4 m-0 list-none"><li class="code-block-button bg-[#fc605d]"></li><li class="code-block-button bg-[#fcbb40]"></li><li class="code-block-button bg-[#33c648]"></li></ul>code</div><pre class="prism-code language-js"><div class="inline-block min-w-full"><span class="token-line"><span class="code-block-line-number">1</span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">2</span><span class="token plain">  </span><span class="token comment">// [前序遍历钩子位置]</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">3</span><span class="token plain">  </span><span class="token function">traverse</span><span class="token punctuation">(</span><span class="token plain">root</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">4</span><span class="token plain">  </span><span class="token comment">// [中序遍历钩子位置]</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">5</span><span class="token plain">  </span><span class="token function">traverse</span><span class="token punctuation">(</span><span class="token plain">root</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">6</span><span class="token plain">  </span><span class="token comment">// [后序遍历钩子位置]</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">7</span><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></span></div></pre></div>
<p>上面代码中的三个位置，前序遍历、中序遍历、后序遍历，相当于三个“钩子”，允许你在递归遍历的过程中执行一些额外的操作。</p>
<p>下面用一个最简单的例子来说明：</p>
<p><a href="https://leetcode.cn/problems/invert-binary-tree/">Leetcode 第 226 题</a>，翻转一棵二叉树，示例：</p>
<div class="my-8 rounded-2xl overflow-hidden bg-[#282c34]"><div class="relative px-4 py-2 text-sm font-bold text-white text-center"><ul class="absolute inset-y-0 left-0 flex items-center gap-2 px-4 m-0 list-none"><li class="code-block-button bg-[#fc605d]"></li><li class="code-block-button bg-[#fcbb40]"></li><li class="code-block-button bg-[#33c648]"></li></ul>code</div><pre class="prism-code language-undefined"><div class="inline-block min-w-full"><span class="token-line"><span class="code-block-line-number">1</span><span class="token plain">// 输入</span></span><span class="token-line"><span class="code-block-line-number">2</span><span class="token plain">     4</span></span><span class="token-line"><span class="code-block-line-number">3</span><span class="token plain">   /   \</span></span><span class="token-line"><span class="code-block-line-number">4</span><span class="token plain">  2     7</span></span><span class="token-line"><span class="code-block-line-number">5</span><span class="token plain"> / \   / \</span></span><span class="token-line"><span class="code-block-line-number">6</span><span class="token plain">1   3 6   9</span></span><span class="token-line"><span class="code-block-line-number">7</span><span class="token plain">
</span></span><span class="token-line"><span class="code-block-line-number">8</span><span class="token plain">// 输出</span></span><span class="token-line"><span class="code-block-line-number">9</span><span class="token plain">     4</span></span><span class="token-line"><span class="code-block-line-number">10</span><span class="token plain">   /   \</span></span><span class="token-line"><span class="code-block-line-number">11</span><span class="token plain">  7     2</span></span><span class="token-line"><span class="code-block-line-number">12</span><span class="token plain"> / \   / \</span></span><span class="token-line"><span class="code-block-line-number">13</span><span class="token plain">9   6 3   1</span></span></div></pre></div>
<p>这道题用前序遍历，按照上面的框架代入，还是比较简单的：</p>
<div class="my-8 rounded-2xl overflow-hidden bg-[#282c34]"><div class="relative px-4 py-2 text-sm font-bold text-white text-center"><ul class="absolute inset-y-0 left-0 flex items-center gap-2 px-4 m-0 list-none"><li class="code-block-button bg-[#fc605d]"></li><li class="code-block-button bg-[#fcbb40]"></li><li class="code-block-button bg-[#33c648]"></li></ul>code</div><pre class="prism-code language-js"><div class="inline-block min-w-full"><span class="token-line"><span class="code-block-line-number">1</span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">2</span><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">root </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">3</span><span class="token plain">  </span><span class="token comment">// 前序遍历</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">4</span><span class="token plain">  </span><span class="token punctuation">[</span><span class="token plain">root</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">,</span><span class="token plain"> root</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token plain">root</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">,</span><span class="token plain"> root</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">5</span><span class="token plain">  </span><span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token plain">root</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">6</span><span class="token plain">  </span><span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token plain">root</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">7</span><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> root</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">8</span><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></span></div></pre></div>
<p>我们在前序的位置，将根节点的左右子树进行互换，然后再分别递归翻转左右两棵子树，最终将整棵二叉树进行翻转。</p>
<p>这道题也可以用后序遍历来做，先将根节点的左右子树分别翻转完成，再将二者进行互换，如下：</p>
<div class="my-8 rounded-2xl overflow-hidden bg-[#282c34]"><div class="relative px-4 py-2 text-sm font-bold text-white text-center"><ul class="absolute inset-y-0 left-0 flex items-center gap-2 px-4 m-0 list-none"><li class="code-block-button bg-[#fc605d]"></li><li class="code-block-button bg-[#fcbb40]"></li><li class="code-block-button bg-[#33c648]"></li></ul>code</div><pre class="prism-code language-js"><div class="inline-block min-w-full"><span class="token-line"><span class="code-block-line-number">1</span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">2</span><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">root </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">3</span><span class="token plain">  </span><span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token plain">root</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">4</span><span class="token plain">  </span><span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token plain">root</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">5</span><span class="token plain">  </span><span class="token comment">// 后序遍历</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">6</span><span class="token plain">  </span><span class="token punctuation">[</span><span class="token plain">root</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">,</span><span class="token plain"> root</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token plain">root</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">,</span><span class="token plain"> root</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">7</span><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> root</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="code-block-line-number">8</span><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></span></div></pre></div></div></article></main></main><footer class="h-20 flex items-center justify-center text-sm text-neutral-400"><div>Build with ♥ @GZ</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"meta":{"title":"算法小抄——“二叉树”的套路","date":"NOV 12, 2021","desc":"“树”是最常见的数据结构之一，与“二叉树”相关的题也是 Leetcode 中最为常见的。而且大部分算法技巧，都与树的遍历有关，很多算法题，本质上就是树的遍历。二叉树的题目，都可以用框架去解决。","type":"gibberish"},"code":"var Component=(()=\u003e{var h=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var m=(e,n)=\u003e()=\u003e(n||e((n={exports:{}}).exports,n),n.exports),j=(e,n)=\u003e{for(var t in n)c(e,t,{get:n[t],enumerable:!0})},l=(e,n,t,i)=\u003e{if(n\u0026\u0026typeof n==\"object\"||typeof n==\"function\")for(let o of u(n))!g.call(e,o)\u0026\u0026o!==t\u0026\u0026c(e,o,{get:()=\u003en[o],enumerable:!(i=p(n,o))||i.enumerable});return e};var v=(e,n,t)=\u003e(t=e!=null?h(f(e)):{},l(n||!e||!e.__esModule?c(t,\"default\",{value:e,enumerable:!0}):t,e)),x=e=\u003el(c({},\"__esModule\",{value:!0}),e);var a=m((y,s)=\u003e{s.exports=_jsx_runtime});var L={};j(L,{default:()=\u003eT,frontmatter:()=\u003e_});var r=v(a()),_={title:\"\\u7B97\\u6CD5\\u5C0F\\u6284\\u2014\\u2014\\u201C\\u4E8C\\u53C9\\u6811\\u201D\\u7684\\u5957\\u8DEF\",date:\"NOV 12, 2021\",desc:\"\\u201C\\u6811\\u201D\\u662F\\u6700\\u5E38\\u89C1\\u7684\\u6570\\u636E\\u7ED3\\u6784\\u4E4B\\u4E00\\uFF0C\\u4E0E\\u201C\\u4E8C\\u53C9\\u6811\\u201D\\u76F8\\u5173\\u7684\\u9898\\u4E5F\\u662F Leetcode \\u4E2D\\u6700\\u4E3A\\u5E38\\u89C1\\u7684\\u3002\\u800C\\u4E14\\u5927\\u90E8\\u5206\\u7B97\\u6CD5\\u6280\\u5DE7\\uFF0C\\u90FD\\u4E0E\\u6811\\u7684\\u904D\\u5386\\u6709\\u5173\\uFF0C\\u5F88\\u591A\\u7B97\\u6CD5\\u9898\\uFF0C\\u672C\\u8D28\\u4E0A\\u5C31\\u662F\\u6811\\u7684\\u904D\\u5386\\u3002\\u4E8C\\u53C9\\u6811\\u7684\\u9898\\u76EE\\uFF0C\\u90FD\\u53EF\\u4EE5\\u7528\\u6846\\u67B6\\u53BB\\u89E3\\u51B3\\u3002\",type:\"gibberish\"};function d(e){let n=Object.assign({p:\"p\",pre:\"pre\",code:\"code\",a:\"a\"},e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:\"\\u201C\\u6811\\u201D\\u662F\\u6700\\u5E38\\u89C1\\u7684\\u6570\\u636E\\u7ED3\\u6784\\u4E4B\\u4E00\\uFF0C\\u4E0E\\u201C\\u4E8C\\u53C9\\u6811\\u201D\\u76F8\\u5173\\u7684\\u9898\\u4E5F\\u662F Leetcode \\u4E2D\\u6700\\u5E38\\u89C1\\u7684\\u3002\\u800C\\u4E14\\u5927\\u90E8\\u5206\\u7B97\\u6CD5\\u6280\\u5DE7\\uFF0C\\u90FD\\u4E0E\\u6811\\u7684\\u904D\\u5386\\u6709\\u5173\\uFF0C\\u5F88\\u591A\\u7B97\\u6CD5\\u9898\\uFF0C\\u672C\\u8D28\\u4E0A\\u5C31\\u662F\\u6811\\u7684\\u904D\\u5386\\u3002\\u4E8C\\u53C9\\u6811\\u7684\\u9898\\u76EE\\uFF0C\\u90FD\\u53EF\\u4EE5\\u7528\\u4E0B\\u9762\\u7684\\u6846\\u67B6\\u53BB\\u89E3\\u51B3\\uFF1A\"}),`\n`,(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:\"language-js\",children:`function traverse(root) {\n  // [\\u524D\\u5E8F\\u904D\\u5386\\u94A9\\u5B50\\u4F4D\\u7F6E]\n  traverse(root.left);\n  // [\\u4E2D\\u5E8F\\u904D\\u5386\\u94A9\\u5B50\\u4F4D\\u7F6E]\n  traverse(root.right);\n  // [\\u540E\\u5E8F\\u904D\\u5386\\u94A9\\u5B50\\u4F4D\\u7F6E]\n}\n`})}),`\n`,(0,r.jsx)(n.p,{children:\"\\u4E0A\\u9762\\u4EE3\\u7801\\u4E2D\\u7684\\u4E09\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u524D\\u5E8F\\u904D\\u5386\\u3001\\u4E2D\\u5E8F\\u904D\\u5386\\u3001\\u540E\\u5E8F\\u904D\\u5386\\uFF0C\\u76F8\\u5F53\\u4E8E\\u4E09\\u4E2A\\u201C\\u94A9\\u5B50\\u201D\\uFF0C\\u5141\\u8BB8\\u4F60\\u5728\\u9012\\u5F52\\u904D\\u5386\\u7684\\u8FC7\\u7A0B\\u4E2D\\u6267\\u884C\\u4E00\\u4E9B\\u989D\\u5916\\u7684\\u64CD\\u4F5C\\u3002\"}),`\n`,(0,r.jsx)(n.p,{children:\"\\u4E0B\\u9762\\u7528\\u4E00\\u4E2A\\u6700\\u7B80\\u5355\\u7684\\u4F8B\\u5B50\\u6765\\u8BF4\\u660E\\uFF1A\"}),`\n`,(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:\"https://leetcode.cn/problems/invert-binary-tree/\",children:\"Leetcode \\u7B2C 226 \\u9898\"}),\"\\uFF0C\\u7FFB\\u8F6C\\u4E00\\u68F5\\u4E8C\\u53C9\\u6811\\uFF0C\\u793A\\u4F8B\\uFF1A\"]}),`\n`,(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:`// \\u8F93\\u5165\n     4\n   /   \\\\\n  2     7\n / \\\\   / \\\\\n1   3 6   9\n\n// \\u8F93\\u51FA\n     4\n   /   \\\\\n  7     2\n / \\\\   / \\\\\n9   6 3   1\n`})}),`\n`,(0,r.jsx)(n.p,{children:\"\\u8FD9\\u9053\\u9898\\u7528\\u524D\\u5E8F\\u904D\\u5386\\uFF0C\\u6309\\u7167\\u4E0A\\u9762\\u7684\\u6846\\u67B6\\u4EE3\\u5165\\uFF0C\\u8FD8\\u662F\\u6BD4\\u8F83\\u7B80\\u5355\\u7684\\uFF1A\"}),`\n`,(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:\"language-js\",children:`function invertTree(root) {\n  if (root === null) return null;\n  // \\u524D\\u5E8F\\u904D\\u5386\n  [root.left, root.right] = [root.right, root.left];\n  invertTree(root.left);\n  invertTree(root.right);\n  return root;\n}\n`})}),`\n`,(0,r.jsx)(n.p,{children:\"\\u6211\\u4EEC\\u5728\\u524D\\u5E8F\\u7684\\u4F4D\\u7F6E\\uFF0C\\u5C06\\u6839\\u8282\\u70B9\\u7684\\u5DE6\\u53F3\\u5B50\\u6811\\u8FDB\\u884C\\u4E92\\u6362\\uFF0C\\u7136\\u540E\\u518D\\u5206\\u522B\\u9012\\u5F52\\u7FFB\\u8F6C\\u5DE6\\u53F3\\u4E24\\u68F5\\u5B50\\u6811\\uFF0C\\u6700\\u7EC8\\u5C06\\u6574\\u68F5\\u4E8C\\u53C9\\u6811\\u8FDB\\u884C\\u7FFB\\u8F6C\\u3002\"}),`\n`,(0,r.jsx)(n.p,{children:\"\\u8FD9\\u9053\\u9898\\u4E5F\\u53EF\\u4EE5\\u7528\\u540E\\u5E8F\\u904D\\u5386\\u6765\\u505A\\uFF0C\\u5148\\u5C06\\u6839\\u8282\\u70B9\\u7684\\u5DE6\\u53F3\\u5B50\\u6811\\u5206\\u522B\\u7FFB\\u8F6C\\u5B8C\\u6210\\uFF0C\\u518D\\u5C06\\u4E8C\\u8005\\u8FDB\\u884C\\u4E92\\u6362\\uFF0C\\u5982\\u4E0B\\uFF1A\"}),`\n`,(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:\"language-js\",children:`function invertTree(root) {\n  if (root === null) return null;\n  invertTree(root.left);\n  invertTree(root.right);\n  // \\u540E\\u5E8F\\u904D\\u5386\n  [root.left, root.right] = [root.right, root.left];\n  return root;\n}\n`})})]})}function b(e={}){let{wrapper:n}=e.components||{};return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(d,e)})):d(e)}var T=b;return x(L);})();\n;return Component;"},"__N_SSG":true},"page":"/post/[id]","query":{"id":"solving-tree-problems"},"buildId":"5gWJ-3w7KsPABD87B5u4P","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>