---
title: "JavaScript 中的树型数据结构"
date: "2020-01-01"
desc: "树有很多变体(如堆、 BST 等) ，可用于解决与调度、图像处理、数据库等相关的问题。许多复杂的问题可能看起来和树没有关系，但是实际上可以表示为一个问题。我们还将讨论这些问题(在本系列后面的部分中) ，看看树是如何使看似复杂的问题更容易理解和解决的。"
---

# 引言

为二叉树实现一个节点是非常简单的。

```js
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}
// usage
const root = new Node(2);
root.left = new Node(1);
root.right = new Node(3);
```

因此，[这几行代码](http://www.google.com)将为我们创建一个二叉树，它看起来像这样：

```js
           2
        /      \
       /         \
     1            3
   /   \        /    \
null  null   null   null
```

这很简单。现在，我们如何使用这个呢？

# 遍历

> 让我们从试图遍历这些连接的树节点（或整颗树）开始。就像我们可以迭代一个数组一样，如果我们也可以“迭代”树节点就更好了。然而，树并不是像数组那样的线性数据结构，因此遍历这些数据结构的方法不止一种。我们可以将遍历方法大致分为以下几类:

- 广度优先遍历
- 深度优先遍历

# 广度优先搜索/遍历（BFS）

在这种方法中，我们逐层遍历树。我们将从根开始，然后覆盖所有的子级，以及覆盖所有的二级子级，以此类推。例如，对于上面的树，遍历会得到如下结果：

```js
2, 1, 3;
```

下面是一个略微复杂的树的例子，使得这个更容易理解：

要实现这种形式的遍历，我们可以使用一个队列（先进先出）数据结构。下面是整个算法的样子：

1. 初始化一个包含`root`的队列
2. 从队列中删除第一项
3. 将弹出项的左右子项推入队列
4. 重复步骤 2 和 3，直到队列为空

下面是这个算法实现后的样子：

```js
function walkBFS(root) {
  if (root === null) return;

  const queue = [root];
  while (queue.length) {
    const item = queue.shift();
    // do something
    console.log(item);

    if (item.left) queue.push(item.left);
    if (item.right) queue.push(item.right);
  }
}
```
