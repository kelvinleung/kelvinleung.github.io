---
title: "JavaScript 的“编译”过程都做了什么？"
date: "OCT 29, 2021"
desc: "所谓的“编译”，并不是“编译型语言”的那个编译，而是指在 JS 代码执行之前，解析器所进行的一系列动作，像词法分析、变量初始化等。由于它们发生在代码真正“执行”之前，所以大家习惯称之为“编译”或“预编译”。整个“编译”阶段，主要涉及到的是执行上下文与执行栈（调用栈）这两个核心的概念，了解这两个概念，对于理解 JS 的底层执行机制，如变量提升、this、闭包等，都会有很大的帮助。"
---

一切要从网上看到的一道面试题说起：

```js
// 请写出下面代码的输出结果：
function fn(a, c) {
  console.log(a); // f a() {}
  var a = 123;
  console.log(a); // 123
  console.log(c); // f c() {}
  function a() {}
  if (false) {
    var d = 678;
  }
  console.log(d); // undefined
  console.log(b); // undefined
  var b = function () {};
  console.log(b); // f () {}
  function c() {}
  console.log(c); // f c() {}
}
fn(1, 2);
```

当时我瞄了一眼，这不很简单么，啪一下就做完了。回头一看答案，第一个`console.log(a)`居然不是`1`，什么情况？经过一番研究，查了无数资料，我终于搞明白了。原来 JS 居然也有“编译”过程，一些奇奇怪怪的事情都发生在这个阶段中。

可是，JS 明明是一门**解析型语言**，哪来的编译？

其实，这里所谓的“编译”，并不是“编译型语言”的那个编译，而是指在 JS 代码执行之前，JS 引擎所进行的一系列动作，像词法分析、变量初始化等。由于它们发生在代码真正“执行”之前，所以大家习惯称之为“编译”或“预编译”。了解 JS “预编译”的过程，对于理解 JS 的底层执行机制，如变量提升、`this`、闭包等，都会有很大的帮助。

## 执行上下文（Execution Context，下面简称 EC）

> An execution context is a specification device that is used to track the runtime evaluation of code by an ECMAScript implementation.

所谓的 EC，指的是 JS 解析运行的环境，是一个抽象的概念。所有 JS 的代码，都是在 EC 中运行的。EC 有三种类型：

- **全局执行上下文（Global Execution Context）**：默认的 EC，所有不是写在函数里的代码，都运行在 GEC 中。GEC 会创建一个全局对象`window`（浏览器环境），并将 `this` 指向 `window`。所有 JS 程序有且只有唯一的一个 GEC。
- **函数执行上下文（Function Execution Context）**：每一次函数被调用时，都会为这个函数创建一个全新的 EC。每个函数都有自己的 EC，当且仅当在被调用时才会创建，而每个程序可以有无数个函数执行上下文。
- **Eval 函数执行上下文（Eval Function Execution Context）**：每段在`eval`中执行的代码，都会有它对应的执行上下文。由于`eval`尽量还是少用，可以暂时忽略它。

## 执行栈/调用栈（Execution Stack，下面简称 ES）

执行栈（有些语言也叫“调用栈”，Calling Stack）顾名思义，是一个后进先出的“栈”，用于存放所有 JS 代码执行过种中产生的执行上下文。JS 引擎在开始执行代码之前，首先会创建一个 GEC，然后把它压入执行栈中。当代码执行到有函数调用的时候，又会为该函数创建 EC 并压进 ES。JS 引擎执行栈顶的 EC 所对应的函数，当该函数执行完毕后，它的 EC 从 ES 中弹出，然后再继续执行下一个 EC 对应的函数，直至所有代码执行完毕，最底层的 GEC 最后弹出，整个程序执行完毕。以下面的代码为例：

```js
// 1. 先创建一个 GEC，入栈
let a = "Hello World!";
function first() {
  console.log("Inside first function");
  second(); // 3. 调用 second() 时创建一个 FEC，入栈，second-EC
  // 4. 执行 second() 结束，弹出 second-EC
  console.log("Again inside first function");
}
function second() {
  console.log("Inside second function");
}
first(); // 2. 调用 first() 时创建一个 FEC，入栈，first-EC
// 5. 执行 first() 结束，弹出 first-EC
console.log("Inside Global Execution Context");
// 6. 代码执行完毕，弹出 GEC
```

程序的执行过程为：

1. 创建一个全局执行上下文，压入执行栈
2. 执行全局代码，到第 12 行，调用 first() 函数，为其创建函数执行上下文，first-FEC，压入执行栈
3. 执行 first() 中的代码，到第 5 行，调用 second() 函数，为其创建函数执行上下文，second-FEC，压入执行栈
4. 执行 second() 中的代码，结束后弹出 second-FEC
5. 继续执行 first() 中的代码，结束后弹出 first-FEC
6. 继续执行全局代码，结束后弹出 GEC，整个程序结束运行

为了更直观地展示整个过程，我做了下面的动图：

![执行栈](/images/compilation-in-javascript/excecution-stack.gif)

## 执行上下文的创建

程序在每次调用函数的时候，JS 引擎都会创建一个新的执行上下文，这个创建的过程又分为两个阶段，分别是**创建阶段**和**执行阶段**。不同版本的规范对这两个过程有着不同的定义，一开始我还以为是我理解错了，很多资料对不上。后来又查了更多资料，看了规范，才发现是新的规范里作了调整，不过基本上是大同小异。

### 旧规范（ES1/3）

在网上能找到的资料中，尤其是国内的中文语境下，大多数都是基于旧规范的解析。其核心概念有**AO（Activation Object，活跃对象）**、**VO（Variable Object，变量对象）**、**作用域（Scope Chain）**。

### 新规范（ES5+）

执行上下文在创建阶段被创建，随之创建的还有以下两个组件（component）：

1. 词法环境（LexicalEnvironment）
2. 变量环境（VariableEnvironment)

因此，执行上下文也可以用以下的伪代码表示：

```js
ExecutionContext = {
  LexicalEnvironment // 指向内存中的词法环境
  VariableEnvironment // 指向内存中的变量环境
}
```

#### 环境（Environment）

[ES6 标准](https://262.ecma-international.org/6.0/#sec-lexical-environments)中对词法环境的定义为：

> A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment.

简单来说，词法环境就是一个包含了标识符与变量间映射关系的结构（这里的标识符指的是变量/函数名，变量指的是实际的对象以及原始值，其中对象又包括函数对象与数组对象）。词法环境，又包含了以下三个组件：

1. 环境记录（Environment Record）
2. 外部环境引用（Reference to the outer environment）
3. This 绑定

## 变量提升题目的解题步骤

## 参考资料

1. [Understanding Execution Context and Execution Stack in Javascript](https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0)
2. [Execution context, Scope chain and JavaScript internals](https://medium.com/@happymishra66/execution-context-in-javascript-319dd72e8e2c)
